# -*- coding: utf-8 -*-
"""Forecasting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NTqAAzYDNJpzilmjufP1uwwAUNxysBLj
"""

import pandas as pd
from datetime import datetime
from sklearn.linear_model import LinearRegression

data=pd.read_csv('/content/dataset_solution_challenge.csv')

data.head()

data.info()

data = data.fillna(data.median(numeric_only=True))

data.info()

data['Date'] = pd.to_datetime(data['Date'], format='%d-%m-%Y')

data.info()

# Getting summary statistics for specific columns
specific_columns_summary = data[['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene', 'AQI']].describe()
specific_columns_summary

import matplotlib.pyplot as plt
import seaborn as sns

# Extracting year from the 'Date' column
data['Year'] = data['Date'].dt.year

# List of numerical features
numerical_features = ['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene', 'AQI']

# Loop over each numerical feature
for feature in numerical_features:
    plt.figure(figsize=(12, 6))

    # Histogram
    plt.subplot(2, 2, 1)
    for year, year_data in data.groupby('Year'):
        sns.histplot(data=year_data, x=feature, kde=True, label=year)
    plt.title(f'Histogram of {feature}')
    plt.xlabel(feature)
    plt.ylabel('Frequency')
    plt.legend(title='Year')

    # Box plot
    plt.subplot(2, 2, 2)
    sns.boxplot(data=data, x='Year', y=feature)
    plt.title(f'Box plot of {feature}')
    plt.xlabel('Year')
    plt.ylabel(feature)

    # Density plot
    plt.subplot(2, 2, 3)
    for year, year_data in data.groupby('Year'):
        sns.kdeplot(data=year_data, x=feature, fill=True, label=year)
    plt.title(f'Density plot of {feature}')
    plt.xlabel(feature)
    plt.ylabel('Density')
    plt.legend(title='Year')

    plt.tight_layout()
    plt.show()

# Loop over each numerical feature
for feature in numerical_features:
    plt.figure(figsize=(10, 6))

    # Plotting curve graph for each feature
    sns.lineplot(data=data, x='Year', y=feature, marker='o')

    plt.title(f'{feature} Over the Years')
    plt.xlabel('Year')
    plt.ylabel(feature)
    plt.grid(True)

    plt.tight_layout()
    plt.show()

for feature in numerical_features:
    plt.figure(figsize=(10, 6))

    # Plotting scatter plot for each feature
    sns.scatterplot(data=data, x=data.index, y=feature, marker='.')

    plt.title(f'{feature} Over Time')
    plt.xlabel('Time (Index)')
    plt.ylabel(feature)
    plt.grid(True)

    plt.tight_layout()
    plt.show()

# Scatter plot for each air quality parameter vs AQI
plt.figure(figsize=(12, 8))
for feature in ['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']:
    sns.scatterplot(data=data, x=feature, y='AQI', label=feature, alpha=0.5)
plt.title('Scatter plot of Air Quality Parameters vs AQI')
plt.xlabel('Air Quality Parameter')
plt.ylabel('AQI')
plt.legend()
plt.grid(True)
plt.show()

# Pair plot
sns.pairplot(data=data[['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene', 'AQI']])
plt.suptitle('Pair Plot of Air Quality Parameters')
plt.show()

# Correlation matrix
correlation_matrix = data[['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene', 'AQI']].corr()

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Air Quality Parameters')
plt.show()

# Define colors for each AQI bucket category
palette_colors = {'Good': 'green', 'Satisfactory': 'yellow', 'Moderate': 'orange', 'Poor': 'red', 'Very Poor': 'purple', 'Severe': 'brown'}

# Count plot for AQI_Bucket with custom colors
plt.figure(figsize=(8, 6))
sns.countplot(data=data, x='AQI_Bucket', order=data['AQI_Bucket'].value_counts().index, palette=palette_colors)
plt.title('Count of AQI Bucket')
plt.xlabel('AQI Bucket')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

# Grouping data by year and calculating the mean for each feature
mean_yearly_data = data.groupby('Year').mean()

# Plotting mean of each feature year-wise
plt.figure(figsize=(12, 8))
for feature in mean_yearly_data.columns:
    plt.plot(mean_yearly_data.index, mean_yearly_data[feature], marker='o', label=feature)

plt.title('Mean of Air Quality Parameters Year-wise')
plt.xlabel('Year')
plt.ylabel('Mean Value')
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.grid(True)
plt.xticks(mean_yearly_data.index)
plt.tight_layout()
plt.show()

"""# **USING RANDOM FOREST ALGORITHM**"""

data

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error

# Define features (X) and target variable (y)
X = data[['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']]
y = data['AQI']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize the Random Forest regressor
rf_regressor = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the Random Forest model
rf_regressor.fit(X_train, y_train)

# Predict the AQI for the test set
y_pred = rf_regressor.predict(X_test)

# Evaluate the performance of the model
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)

plt.figure(figsize=(10, 6))

# Plotting actual vs predicted AQI values
plt.scatter(y_test, y_pred, color='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)  # Plotting the diagonal line

plt.title('Actual vs Predicted AQI')
plt.xlabel('Actual AQI')
plt.ylabel('Predicted AQI')
plt.grid(True)
plt.show()

"""# **Forecasting AQI**"""

# Extracting 'Date' and 'AQI' columns
prophet_data = data[['Date', 'AQI']].copy()

# Renaming columns to match Prophet's requirements
prophet_data.columns = ['ds', 'y']

# Displaying the first few rows of the prepared data
print(prophet_data.head())

from prophet import Prophet

# Initialize Prophet model
model = Prophet()

# Fit the model to the data
model.fit(prophet_data)

# Finding the maximum date in the dataset
max_date = prophet_data['ds'].max()

# Making future predictions starting from the day after the maximum date
future_dates = pd.date_range(start=max_date + pd.Timedelta(days=1), periods=1825, freq='D')

# Creating a DataFrame for the future dates
future_df = pd.DataFrame({'ds': future_dates})

# Displaying the first few rows of the future dates DataFrame
print(future_df.head())

# Making predictions for the future dates
forecast = model.predict(future_df)

# Displaying the first few rows of the forecast DataFrame
print(forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head())

# Plotting the actual AQI values
plt.figure(figsize=(12, 6))
plt.plot(prophet_data['ds'], prophet_data['y'], label='Actual AQI', color='blue')

# Plotting the forecasted values
plt.plot(forecast['ds'], forecast['yhat'], label='Forecasted AQI', color='red')

# Plotting the prediction intervals
plt.fill_between(forecast['ds'], forecast['yhat_lower'], forecast['yhat_upper'], color='pink', alpha=0.3)

# Adding labels and title
plt.title('Forecasted AQI vs Actual AQI')
plt.xlabel('Date')
plt.ylabel('AQI')
plt.legend()
plt.grid(True)
plt.show()

# Extracting the forecasted values and prediction intervals
forecast_df = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

# Saving the forecasted values to a CSV file
forecast_df.to_csv('forecasted_aqi.csv', index=False)

print("Forecasted values saved to 'forecasted_aqi.csv'.")

"""# **Forecasting PM2.5**"""

# Extracting 'Date' and 'PM2.5' columns
pm25_data = data[['Date', 'PM2.5']].copy()

# Renaming columns to match Prophet's requirements
pm25_data.columns = ['ds', 'y']

# Displaying the first few rows of the prepared data
print(pm25_data.head())

# Initialize Prophet model
pm25_model = Prophet()

# Fit the model to the data
pm25_model.fit(pm25_data)

# Making future predictions for the next 365 days
future_pm25_dates = pm25_model.make_future_dataframe(periods=1825)

# Making predictions for the future dates
pm25_forecast = pm25_model.predict(future_pm25_dates)

# Displaying the first few rows of the forecast DataFrame
print(pm25_forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head())

# Plotting the actual PM2.5 values
plt.figure(figsize=(12, 6))
plt.plot(pm25_data['ds'], pm25_data['y'], label='Actual PM2.5', color='blue')

# Plotting the forecasted values
plt.plot(pm25_forecast['ds'], pm25_forecast['yhat'], label='Forecasted PM2.5', color='red')

# Plotting the prediction intervals
plt.fill_between(pm25_forecast['ds'], pm25_forecast['yhat_lower'], pm25_forecast['yhat_upper'], color='pink', alpha=0.3)

# Adding labels and title
plt.title('Forecasted PM2.5 vs Actual PM2.5')
plt.xlabel('Date')
plt.ylabel('PM2.5')
plt.legend()
plt.grid(True)
plt.show()

# Extracting the forecasted values and prediction intervals
pm25_forecast_df = pm25_forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]

# Saving the forecasted values to a CSV file
pm25_forecast_df.to_csv('forecasted_pm25.csv', index=False)

print("Forecasted PM2.5 values saved to 'forecasted_pm25.csv'.")

"""# **Forecasting PM10**"""

# Prepare data for PM10 forecasting
pm10_data = data[['Date', 'PM10']].copy()
pm10_data.columns = ['ds', 'y']

# Initialize and fit the Prophet model for PM10
pm10_model = Prophet()
pm10_model.fit(pm10_data)

# Make future predictions for PM10
future_pm10_dates = pm10_model.make_future_dataframe(periods=1825)
pm10_forecast = pm10_model.predict(future_pm10_dates)

# Plotting the forecasted PM10 values alongside the actual values
plt.figure(figsize=(12, 6))
plt.plot(pm10_data['ds'], pm10_data['y'], label='Actual PM10', color='blue')
plt.plot(pm10_forecast['ds'], pm10_forecast['yhat'], label='Forecasted PM10', color='red')
plt.fill_between(pm10_forecast['ds'], pm10_forecast['yhat_lower'], pm10_forecast['yhat_upper'], color='pink', alpha=0.3)
plt.title('Forecasted PM10 vs Actual PM10')
plt.xlabel('Date')
plt.ylabel('PM10')
plt.legend()
plt.grid(True)
plt.show()

# Save the forecasted PM10 values to a CSV file
pm10_forecast_df = pm10_forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
pm10_forecast_df.to_csv('forecasted_pm10.csv', index=False)
print("Forecasted PM10 values saved to 'forecasted_pm10.csv'.")

"""# **Forecasting NO**"""

# Prepare data for NO forecasting
no_data = data[['Date', 'NO']].copy()
no_data.columns = ['ds', 'y']

# Initialize and fit the Prophet model for NO
no_model = Prophet()
no_model.fit(no_data)

# Make future predictions for NO
future_no_dates = no_model.make_future_dataframe(periods=1825)
no_forecast = no_model.predict(future_no_dates)

# Plotting the forecasted NO values alongside the actual values
plt.figure(figsize=(12, 6))
plt.plot(no_data['ds'], no_data['y'], label='Actual NO', color='blue')
plt.plot(no_forecast['ds'], no_forecast['yhat'], label='Forecasted NO', color='red')
plt.fill_between(no_forecast['ds'], no_forecast['yhat_lower'], no_forecast['yhat_upper'], color='pink', alpha=0.3)
plt.title('Forecasted NO vs Actual NO')
plt.xlabel('Date')
plt.ylabel('NO')
plt.legend()
plt.grid(True)
plt.show()

# Save the forecasted NO values to a CSV file
no_forecast_df = no_forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
no_forecast_df.to_csv('forecasted_no.csv', index=False)
print("Forecasted NO values saved to 'forecasted_no.csv'.")

"""# **ALL OTHER FACTORS**"""

# List of factors to forecast
factors = ['NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']

for factor in factors:
    # Prepare data for the current factor
    factor_data = data[['Date', factor]].copy()
    factor_data.columns = ['ds', 'y']

    # Initialize and fit the Prophet model for the current factor
    factor_model = Prophet()
    factor_model.fit(factor_data)

    # Make future predictions for the current factor
    future_factor_dates = factor_model.make_future_dataframe(periods=1825)
    factor_forecast = factor_model.predict(future_factor_dates)

    # Plotting the forecasted factor values alongside the actual values
    plt.figure(figsize=(12, 6))
    plt.plot(factor_data['ds'], factor_data['y'], label=f'Actual {factor}', color='blue')
    plt.plot(factor_forecast['ds'], factor_forecast['yhat'], label=f'Forecasted {factor}', color='red')
    plt.fill_between(factor_forecast['ds'], factor_forecast['yhat_lower'], factor_forecast['yhat_upper'], color='pink', alpha=0.3)
    plt.title(f'Forecasted {factor} vs Actual {factor}')
    plt.xlabel('Date')
    plt.ylabel(factor)
    plt.legend()
    plt.grid(True)
    plt.show()

    # Save the forecasted factor values to a CSV file
    factor_forecast_df = factor_forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
    factor_forecast_df.to_csv(f'forecasted_{factor.lower()}.csv', index=False)
    print(f"Forecasted {factor} values saved to 'forecasted_{factor.lower()}.csv'.")

"""


# **Single Graph All Forecasting**
"""

# List of factors to forecast
factors = ['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']

# Initialize the figure
plt.figure(figsize=(12, 8))

# Iterate over each factor
for factor in factors:
    # Prepare data for the current factor
    factor_data = data[['Date', factor]].copy()
    factor_data.columns = ['ds', 'y']

    # Initialize and fit the Prophet model for the current factor
    factor_model = Prophet()
    factor_model.fit(factor_data)

    # Make future predictions for the current factor
    future_factor_dates = factor_model.make_future_dataframe(periods=1825)
    factor_forecast = factor_model.predict(future_factor_dates)

    # Plotting the forecasted factor values
    plt.plot(factor_forecast['ds'], factor_forecast['yhat'], label=factor)

# Adding labels and title
plt.title('Forecasted Air Quality Factors')
plt.xlabel('Date')
plt.ylabel('Value')
plt.legend()
plt.grid(True)
plt.show()

# List of factors to forecast
factors = ['PM2.5', 'PM10', 'NO', 'NO2', 'NOx', 'NH3', 'CO', 'SO2', 'O3', 'Benzene', 'Toluene', 'Xylene']

# Initialize an empty DataFrame to store forecasted values
forecasted_data = pd.DataFrame()

# Iterate over each factor
for factor in factors:
    # Prepare data for the current factor
    factor_data = data[['Date', factor]].copy()
    factor_data.columns = ['ds', 'y']

    # Initialize and fit the Prophet model for the current factor
    factor_model = Prophet()
    factor_model.fit(factor_data)

    # Make future predictions for the current factor
    max_date = factor_data['ds'].max()
    future_factor_dates = factor_model.make_future_dataframe(periods=1825, freq='D', include_history=False)
    future_factor_dates = future_factor_dates[future_factor_dates['ds'] > max_date]  # Filter dates after the max date
    factor_forecast = factor_model.predict(future_factor_dates)

    # Add forecasted values to the DataFrame
    forecasted_data[factor] = factor_forecast['yhat']

# Include 'Date' and 'AQI' columns in the forecasted data
forecasted_data['Date'] = factor_forecast['ds']
forecasted_data['AQI'] = data['AQI']

# Reorder columns to have 'Date' and 'AQI' at the beginning
columns = ['Date', 'AQI'] + factors
forecasted_data = forecasted_data[columns]

# Save the forecasted values to a CSV file
forecasted_data.to_csv('Full_Forecasting.csv', index=False)
print("Forecasted factors with Date and AQI saved to 'Full_Forecasting.csv'.")

